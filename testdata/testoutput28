# Tests for the pattern rewriter which precedes regex compilation (without UTF)

#forbid_utf

# Pulling out common prefixes from alternation:

# Simplest case:
# â‡’ a[b-d]
/ab|ac|ad/B
------------------------------------------------------------------
        Bra
        a
        [b-d]
        Ket
        End
------------------------------------------------------------------

# â‡’ a(?:b|c|(d))
/ab|ac|a(d)/B
------------------------------------------------------------------
        Bra
        a
        Bra
        b
        Alt
        c
        Alt
        CBra 1
        d
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

# â‡’ ab[bc]
/abb|abc/B
------------------------------------------------------------------
        Bra
        ab
        [bc]
        Ket
        End
------------------------------------------------------------------

# Inside a group is also OK:
# â‡’ (a[b-d])
/(ab|ac|ad)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        [b-d]
        Ket
        Ket
        End
------------------------------------------------------------------

# Can recurse into deeply nested groups:
# â‡’ (((a[b-d])))
/(((ab|ac|ad)))/B
------------------------------------------------------------------
        Bra
        CBra 1
        CBra 2
        CBra 3
        a
        [b-d]
        Ket
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

# Another variant
# â‡’ (a((a[b-d]))b)
/(a((ab|ac|ad))b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        CBra 2
        CBra 3
        a
        [b-d]
        Ket
        Ket
        b
        Ket
        Ket
        End
------------------------------------------------------------------

# Common prefix covers all of one alternation branch
# â‡’ a(?:|b)
/a|ab/B
------------------------------------------------------------------
        Bra
        a
        Bra
        Alt
        b
        Ket
        Ket
        End
------------------------------------------------------------------

# Multiple identical alternation branches
# (We don't detect this and prune the redundant ones)
/a|ab|a/B
------------------------------------------------------------------
        Bra
        a
        Bra
        Alt
        b
        Alt
        Ket
        Ket
        End
------------------------------------------------------------------

# Can't be rewritten
/.+a|.+b/B
------------------------------------------------------------------
        Bra
        Any+
        a
        Alt
        Any+
        b
        Ket
        End
------------------------------------------------------------------
    aaab
 0: aaa

# Can't be rewritten
/.*b|.*c/B
------------------------------------------------------------------
        Bra
        Any*
        b
        Alt
        Any*
        c
        Ket
        End
------------------------------------------------------------------
    bbbc
 0: bbb

# Can't be rewritten
/.?b|.?c/B
------------------------------------------------------------------
        Bra
        Any?
        b
        Alt
        Any?
        c
        Ket
        End
------------------------------------------------------------------
    bc
 0: b

# However, a quantifier which matches a specific number of times is OK:
# â‡’ .{2}[bc]
/.{2}b|.{2}c/B
------------------------------------------------------------------
        Bra
        Any{2}
        [bc]
        Ket
        End
------------------------------------------------------------------

# Can't be rewritten
# NOTE: During regex compilation, a{1,2} is converted to aa{0,1}
# If this conversion was done earlier, we could pull out a common prefix
# ðŸ¤·
/a{1,2}b|a{1,2}c/B
------------------------------------------------------------------
        Bra
        a
        a{0,1}+
        b
        Alt
        a
        a{0,1}+
        c
        Ket
        End
------------------------------------------------------------------

# Possessive quantifiers are OK:
# â‡’ .++[ab]
/.++a|.++b/B
------------------------------------------------------------------
        Bra
        Any++
        [ab]
        Ket
        End
------------------------------------------------------------------

# â‡’ .*+[ab]
/.*+a|.*+b/B
------------------------------------------------------------------
        Bra
        Any*+
        [ab]
        Ket
        End
------------------------------------------------------------------

# â‡’ .?+[ab]
/.?+a|.?+b/B
------------------------------------------------------------------
        Bra
        Any?+
        [ab]
        Ket
        End
------------------------------------------------------------------

# â‡’ .{2,4}+[ab]
/.{2,4}+a|.{2,4}+b/B
------------------------------------------------------------------
        Bra
        Any{2}
        Any{0,2}+
        [ab]
        Ket
        End
------------------------------------------------------------------

# Non-capturing groups can be pulled out ONLY if they don't contain anything
# which the regex engine can backtrack into
# This includes: alternation, non-possessive quantifiers
# â‡’ (?:aa)[bc]
/(?:aa)b|(?:aa)c/B
------------------------------------------------------------------
        Bra
        Bra
        aa
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# Can't be rewritten
/(?:\s|\d)b|(?:\s|\d)c/B
------------------------------------------------------------------
        Bra
        Bra
        \s
        Alt
        \d
        Ket
        b
        Alt
        Bra
        \s
        Alt
        \d
        Ket
        c
        Ket
        End
------------------------------------------------------------------

# Will be rewritten into character class
# â‡’ [ab]b|[ab]c
/(?:a|b)b|(?:a|b)c/B
------------------------------------------------------------------
        Bra
        [ab]
        b
        Alt
        [ab]
        c
        Ket
        End
------------------------------------------------------------------

# Can't be rewritten
/(?:.*)b|(?:.*)c/B
------------------------------------------------------------------
        Bra
        Bra
        Any*
        Ket
        b
        Alt
        Bra
        Any*
        Ket
        c
        Ket
        End
------------------------------------------------------------------
    bbbc
 0: bbb

# Capturing groups can't, because it would change the capture numbers
/(\d)b|(\d)c/B
------------------------------------------------------------------
        Bra
        CBra 1
        \d
        Ket
        b
        Alt
        CBra 2
        \d
        Ket
        c
        Ket
        End
------------------------------------------------------------------
    1b
 0: 1b
 1: 1
    1c
 0: 1c
 1: <unset>
 2: 1

# Will be rewritten into character class
# â‡’ ([ab])b|([ab])c
/(a|b)b|(a|b)c/B
------------------------------------------------------------------
        Bra
        CBra 1
        [ab]
        Ket
        b
        Alt
        CBra 2
        [ab]
        Ket
        c
        Ket
        End
------------------------------------------------------------------
    ab
 0: ab
 1: a
    ac
 0: ac
 1: <unset>
 2: a

# Non-capturing group quantified with *, +, ?
# Can't be pulled out from alternation... but (?:a|b) will be converted to (?:[ab])
/(?:a|b)*b|(?:a|b)*c/B
------------------------------------------------------------------
        Bra
        Brazero
        Bra
        [ab]
        KetRmax
        b
        Alt
        Brazero
        Bra
        [ab]
        KetRmax
        c
        Ket
        End
------------------------------------------------------------------

# Can't be pulled out, but can be converted to use [ab]
/(?:a|b)+b|(?:a|b)+c/B
------------------------------------------------------------------
        Bra
        Bra
        [ab]
        KetRmax
        b
        Alt
        Bra
        [ab]
        KetRmax
        c
        Ket
        End
------------------------------------------------------------------

# Can't be pulled out, but can be converted to use [ab]
/(?:a|b)?b|(?:a|b)?c/B
------------------------------------------------------------------
        Bra
        Brazero
        Bra
        [ab]
        Ket
        b
        Alt
        Brazero
        Bra
        [ab]
        Ket
        c
        Ket
        End
------------------------------------------------------------------

# Lookahead can be pulled out
# â‡’ (?=a)a[AB]
/(?=a)aA|(?=a)aB/B
------------------------------------------------------------------
        Bra
        Assert
        a
        Ket
        a
        [AB]
        Ket
        End
------------------------------------------------------------------

# Lookbehind can be pulled out
# â‡’ (?<=a)[bc]
/(?<=a)b|(?<=a)c/B
------------------------------------------------------------------
        Bra
        Assert back
        Reverse
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# Non-matching lookbehind can't be pulled out (of course)
/(?<=a)b|(?<=b)c/B
------------------------------------------------------------------
        Bra
        Assert back
        Reverse
        a
        Ket
        b
        Alt
        Assert back
        Reverse
        b
        Ket
        c
        Ket
        End
------------------------------------------------------------------

# Negative lookahead can be pulled out
# â‡’ (?!a)[bc]
/(?!a)b|(?!a)c/B
------------------------------------------------------------------
        Bra
        Assert not
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# Negative lookbehind can be pulled out
# â‡’ (?<!a)[bc]
/(?<!a)b|(?<!a)c/B
------------------------------------------------------------------
        Bra
        Assert back not
        Reverse
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# Non-atomic positive lookahead can be pulled out
# â‡’ (*napla:a)[bc]
/(*napla:a)b|(*napla:a)c/B
------------------------------------------------------------------
        Bra
        Non-atomic assert
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# ...but not if the engine might need to backtrack into the NA positive lookahead
/(?|(*napla:.*(\w))a\1|(*napla:.*(\w))ab\1)/B
------------------------------------------------------------------
        Bra
        Non-atomic assert
        Any*
        CBra 1
        \w
        Ket
        Ket
        a
        \1
        Alt
        Non-atomic assert
        Any*
        CBra 1
        \w
        Ket
        Ket
        ab
        \1
        Ket
        End
------------------------------------------------------------------
    abc
 0: ab
 1: b

# Just demonstrating that the matched string would be different if (*napla:.*(\w)) was pulled out:
/(*napla:.*(\w))(?:a\1|ab\1)/
    abc
 0: abc
 1: c

# Non-atomic positive lookbehind can be pulled out
# â‡’ (*naplb:a)[bc]
/(*naplb:a)b|(*naplb:a)c/B
------------------------------------------------------------------
        Bra
        Non-atomic assert back
        Reverse
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------

# ...but not if the engine might need to backtrack into the NA positive lookbehind
/(?|(*naplb:(ab|b))\1|(*naplb:(ab|b))b)/B
------------------------------------------------------------------
        Bra
        Non-atomic assert back
        VReverse
        CBra 1
        ab
        Alt
        b
        Ket
        Ket
        \1
        Alt
        Non-atomic assert back
        VReverse
        CBra 1
        ab
        Alt
        b
        Ket
        Ket
        b
        Ket
        End
------------------------------------------------------------------
    abb
 0: b
 1: b

# Just demonstrating the the matched string would be different if (*naplb:a|b) was pulled out:
/(*naplb:(ab|b))(?:\1|b)/
    abb
 0: b
 1: ab

# Atomic groups can be pulled out
# â‡’ (?>aa)a[bc]
/(?>aa)ab|(?>aa)ac/B
------------------------------------------------------------------
        Bra
        Once
        aa
        Ket
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# Sometimes items are pulled out FROM an atomic group...
# â‡’ (?>a[bc])
/(?>ab|ac)/B
------------------------------------------------------------------
        Bra
        Once
        a
        [bc]
        Ket
        Ket
        End
------------------------------------------------------------------

# Character classes can be pulled out
# â‡’ [a-z][bc]
/[a-z]b|[a-z]c/B
------------------------------------------------------------------
        Bra
        [a-z]
        [bc]
        Ket
        End
------------------------------------------------------------------

# Semantically identical char classes, written in a different way
# NOTE: If char classes were canonicalized before pattern rewriting,
# we could pull out a common prefix here
# ðŸ¤· Too bad
/[abc]b|[a-c]c/B
------------------------------------------------------------------
        Bra
        [a-c]
        b
        Alt
        [a-c]
        c
        Ket
        End
------------------------------------------------------------------

# Character types
# â‡’ \d\s\v\w[ab]
/\d\s\v\wa|\d\s\v\wb/B
------------------------------------------------------------------
        Bra
        \d
        \s
        \v
        \w
        [ab]
        Ket
        End
------------------------------------------------------------------

# Start-of-string anchor
/^a|^b/B
------------------------------------------------------------------
        Bra
        ^
        [ab]
        Ket
        End
------------------------------------------------------------------

# Rewriting still works with options at beginning of regex
/(*NOTEMPTY)(*NO_AUTO_POSSESS)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*NO_START_OPT)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*NO_DOTSTAR_ANCHOR)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*LIMIT_HEAP=10000)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*LIMIT_MATCH=10)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*LIMIT_DEPTH=10)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

/(*CR)ab|ac/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# Dot
/.a|.b/B
------------------------------------------------------------------
        Bra
        Any
        [ab]
        Ket
        End
------------------------------------------------------------------

# Extended regex (with embedded whitespace)
# The whitespace doesn't interfere with rewriting
/(?x) a b  |	a     a  b/B
------------------------------------------------------------------
        Bra
        a
        Bra
        b
        Alt
        ab
        Ket
        Ket
        End
------------------------------------------------------------------

# \Q..\E literal sequences
/\Q$\Ea|\Q$\Eb/B
------------------------------------------------------------------
        Bra
        $
        [ab]
        Ket
        End
------------------------------------------------------------------

# Hex escapes
# 'A' and '\x41' are recognized as equivalent and rewritten
/Aa|\x41b/B
------------------------------------------------------------------
        Bra
        A
        [ab]
        Ket
        End
------------------------------------------------------------------

# Backreferences can be pulled out
/(\w)(?:\1a|\1b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \w
        Ket
        \1
        [ab]
        Ket
        End
------------------------------------------------------------------

# Relative backreferences can be pulled out
/(\w)(?:\g{-1}a|\g{-1}b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \w
        Ket
        \1
        [ab]
        Ket
        End
------------------------------------------------------------------

# Match reset escape can be pulled out
/a\Kb|a\Kc/B
------------------------------------------------------------------
        Bra
        a
        \K
        [bc]
        Ket
        End
------------------------------------------------------------------

# Group with duplicate capture numbers
# â‡’ (a)[bc]
/(?|(a)b|(a)c)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        [bc]
        Ket
        End
------------------------------------------------------------------
    ab
 0: ab
 1: a
    ac
 0: ac
 1: a

# Although capture numbers are the same, capturing groups can't be pulled out
# if they contain anything which the regex engine can backtrack into
/(?|(a*)b|(a*)c)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a*+
        Ket
        b
        Alt
        CBra 1
        a*+
        Ket
        c
        Ket
        End
------------------------------------------------------------------

/(?|(\d|\s)b|(\d|\s)c)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \d
        Alt
        \s
        Ket
        b
        Alt
        CBra 1
        \d
        Alt
        \s
        Ket
        c
        Ket
        End
------------------------------------------------------------------

# Non-capturing group with option letters
/(?i:ab|ac)/B
------------------------------------------------------------------
        Bra
     /i a
        [BCbc]
        Ket
        End
------------------------------------------------------------------

# Named capture groups
# This can't be rewritten, because although the capture group
# names are the same, their numbers are different
/(?J)(?:(?<n>a)b|(?<n>a)c)\k<n>/B
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        a
        Ket
        b
        Alt
        CBra 2
        a
        Ket
        c
        Ket
        \k<n>2
        Ket
        End
------------------------------------------------------------------

# Named capture groups with identical capture group numbers
# These can be rewritten
/(?|(?<n>a)b|(?<n>a)c)\k<n>/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        [bc]
        \1
        Ket
        End
------------------------------------------------------------------

# Capture group condition
# Can't be rewritten
/(a)(?(1)bc|bd)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
      1 Capture ref
        bc
        Alt
        bd
        Ket
        Ket
        End
------------------------------------------------------------------

# Capture group condition (by group name)
# Can't be rewritten
/(?<n>a)(?(<n>)bc|bd)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
      1 Capture ref
        bc
        Alt
        bd
        Ket
        Ket
        End
------------------------------------------------------------------

# Version number condition
# Can't be rewritten
/(?(VERSION>=10.4)ab|ac)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond true
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Lookahead assertion condition
# Can't be rewritten
/(?(?=a)ab|ac)/B
------------------------------------------------------------------
        Bra
        Cond
        Assert
        a
        Ket
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# However, subgroups of a conditional group can be rewritten
/(?(?=a)a(?:bb|bc)|ac)/B
------------------------------------------------------------------
        Bra
        Cond
        Assert
        a
        Ket
        ab
        [bc]
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Lookbehind assertion condition
# Can't be rewritten
/(?(?<=a)ab|ac)/B
------------------------------------------------------------------
        Bra
        Cond
        Assert back
        Reverse
        a
        Ket
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Recursion condition
# Can't be rewritten
/(?(R)ab|ac)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond recurse any
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Recursion condition with explicit number
# Can't be rewritten
/(a)(?(R1)ab|ac)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
        Cond recurse 1
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Recursion condition by name
# Can't be rewritten
/(?<n>a)(?(R&n)ab|ac)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
        Cond recurse 1
        ab
        Alt
        ac
        Ket
        Ket
        End
------------------------------------------------------------------

# Define
/(?(DEFINE) a)b|(?(DEFINE) a)\w/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
         a
        Ket
        b
        Alt
        Cond
        Cond false
         a
        Ket
        \w
        Ket
        End
------------------------------------------------------------------

# Subroutine call by number
# â‡’ (?|(a)|(b))(?1)[bc]
/(?|(a)|(b))(?:(?1)b|(?1)c)/B
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        a
        Ket
        Alt
        CBra 1
        b
        Ket
        Ket
        Recurse
        [bc]
        Ket
        End
------------------------------------------------------------------

# Subroutine call by number, but with non-matching number
/(?:(a)|(b))(?:(?1)b|(?2)c)/B
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        a
        Ket
        Alt
        CBra 2
        b
        Ket
        Ket
        Bra
        Recurse
        b
        Alt
        Recurse
        c
        Ket
        Ket
        End
------------------------------------------------------------------

# Subroutine call by name
# â‡’ (?<n>a)(?&n)[ab]
/(?<n>a)(?:(?&n)a|(?&n)b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Recurse
        [ab]
        Ket
        End
------------------------------------------------------------------

# Subroutine call by name, but with non-matching name
/(?<n>a)(?<m>b)(?:(?&n)a|(?&m)b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        CBra 2
        b
        Ket
        Bra
        Recurse
        a
        Alt
        Recurse
        b
        Ket
        Ket
        End
------------------------------------------------------------------

/(?<abcd>a)(?<abce>b)(?:(?&abce)a|(?&abcd)b)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        CBra 2
        b
        Ket
        Bra
        Recurse
        a
        Alt
        Recurse
        b
        Ket
        Ket
        End
------------------------------------------------------------------

# Callouts are never pulled out
/(?C0)a|(?C0)b/B
------------------------------------------------------------------
        Bra
        Callout 0 5 1
        a
        Alt
        Callout 0 12 1
        b
        Ket
        End
------------------------------------------------------------------

/(?C{ab})a|(?C{ab})b/B
------------------------------------------------------------------
        Bra
        CalloutStr {ab} 4 8 1
        a
        Alt
        CalloutStr {ab} 14 18 1
        b
        Ket
        End
------------------------------------------------------------------

# Callouts are still not pulled out if they are inside a sub-group
/(?:(?C0))a|(?:(?C0))b/B
------------------------------------------------------------------
        Bra
        Bra
        Callout 0 8 1
        Ket
        a
        Alt
        Bra
        Callout 0 19 1
        Ket
        b
        Ket
        End
------------------------------------------------------------------

/(?:(?C{ab}))a|(?:(?C{ab}))b/B
------------------------------------------------------------------
        Bra
        Bra
        CalloutStr {ab} 7 11 1
        Ket
        a
        Alt
        Bra
        CalloutStr {ab} 21 25 1
        Ket
        b
        Ket
        End
------------------------------------------------------------------

/(?>(?C0))a|(?>(?C0))b/B
------------------------------------------------------------------
        Bra
        Once
        Callout 0 8 1
        Ket
        a
        Alt
        Once
        Callout 0 19 1
        Ket
        b
        Ket
        End
------------------------------------------------------------------

/(?=(?C0))a|(?=(?C0))b/B
------------------------------------------------------------------
        Bra
        Assert
        Callout 0 8 1
        Ket
        a
        Alt
        Assert
        Callout 0 19 1
        Ket
        b
        Ket
        End
------------------------------------------------------------------

/(?<=(?C0))a|(?<=(?C0))b/B
------------------------------------------------------------------
        Bra
        Assert back
        Callout 0 9 1
        Ket
        a
        Alt
        Assert back
        Callout 0 21 1
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*ACCEPT) can be pulled out
/(*ACCEPT)ab|(*ACCEPT)ac/B
------------------------------------------------------------------
        Bra
        *ACCEPT
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# (*ACCEPT:name) can be pulled out
/(*ACCEPT:hello)ab|(*ACCEPT:hello)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        *ACCEPT
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# (*ACCEPT:name) but with non-matching names
/(*ACCEPT:hello)ab|(*ACCEPT:goodbye)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        *ACCEPT
        ab
        Alt
        *MARK goodbye
        *ACCEPT
        ac
        Ket
        End
------------------------------------------------------------------

/(*ACCEPT:a)ab|(*ACCEPT:b)ac/B
------------------------------------------------------------------
        Bra
        *MARK a
        *ACCEPT
        ab
        Alt
        *MARK b
        *ACCEPT
        ac
        Ket
        End
------------------------------------------------------------------

# (*FAIL) can be pulled out
/(*FAIL)ab|(*FAIL)ac/B
------------------------------------------------------------------
        Bra
        *FAIL
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# (*FAIL:name) can be pulled out
/(*FAIL:hello)ab|(*FAIL:hello)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        *FAIL
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# (*FAIL:name) but with non-matching names
/(*FAIL:hello)ab|(*FAIL:goodbye)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        *FAIL
        ab
        Alt
        *MARK goodbye
        *FAIL
        ac
        Ket
        End
------------------------------------------------------------------

# (*MARK:name) can be pulled out
/(*MARK:hello)ab|(*MARK:hello)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        a
        [bc]
        Ket
        End
------------------------------------------------------------------

# (*MARK:name) but with non-matching names
/(*MARK:hello)ab|(*MARK:goodbye)ac/B
------------------------------------------------------------------
        Bra
        *MARK hello
        ab
        Alt
        *MARK goodbye
        ac
        Ket
        End
------------------------------------------------------------------

# (*PRUNE) is never pulled out
/(*PRUNE)a|(*PRUNE)b/B
------------------------------------------------------------------
        Bra
        *PRUNE
        a
        Alt
        *PRUNE
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*PRUNE))a|(?:(*PRUNE))b/B
------------------------------------------------------------------
        Bra
        Bra
        *PRUNE
        Ket
        a
        Alt
        Bra
        *PRUNE
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*PRUNE:name) is never pulled out
/(*PRUNE:abc)a|(*PRUNE:abc)b/B
------------------------------------------------------------------
        Bra
        *PRUNE abc
        a
        Alt
        *PRUNE abc
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*PRUNE:abc))a|(?:(*PRUNE:abc))b/B
------------------------------------------------------------------
        Bra
        Bra
        *PRUNE abc
        Ket
        a
        Alt
        Bra
        *PRUNE abc
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*COMMIT) is never pulled out
/(*COMMIT)a|(*COMMIT)b/B
------------------------------------------------------------------
        Bra
        *COMMIT
        a
        Alt
        *COMMIT
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*COMMIT))a|(?:(*COMMIT))b/B
------------------------------------------------------------------
        Bra
        Bra
        *COMMIT
        Ket
        a
        Alt
        Bra
        *COMMIT
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*COMMIT:name) is never pulled out
/(*COMMIT:abc)a|(*COMMIT:abc)b/B
------------------------------------------------------------------
        Bra
        *COMMIT abc
        a
        Alt
        *COMMIT abc
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*COMMIT:abc))a|(?:(*COMMIT:abc))b/B
------------------------------------------------------------------
        Bra
        Bra
        *COMMIT abc
        Ket
        a
        Alt
        Bra
        *COMMIT abc
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*SKIP) is never pulled out
/(*SKIP)a|(*SKIP)b/B
------------------------------------------------------------------
        Bra
        *SKIP
        a
        Alt
        *SKIP
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*SKIP))a|(?:(*SKIP))b/B
------------------------------------------------------------------
        Bra
        Bra
        *SKIP
        Ket
        a
        Alt
        Bra
        *SKIP
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*SKIP:name) is never pulled out
/(*SKIP:abc)a|(*SKIP:abc)b/B
------------------------------------------------------------------
        Bra
        *SKIP abc
        a
        Alt
        *SKIP abc
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*SKIP:abc))a|(?:(*SKIP:abc))b/B
------------------------------------------------------------------
        Bra
        Bra
        *SKIP abc
        Ket
        a
        Alt
        Bra
        *SKIP abc
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*THEN) is never pulled out
/(*THEN)a|(*THEN)b/B
------------------------------------------------------------------
        Bra
        *THEN
        a
        Alt
        *THEN
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*THEN))a|(?:(*THEN))b/B
------------------------------------------------------------------
        Bra
        Bra
        *THEN
        Ket
        a
        Alt
        Bra
        *THEN
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# (*THEN:name) is never pulled out
/(*THEN:abc)a|(*THEN:abc)b/B
------------------------------------------------------------------
        Bra
        *THEN abc
        a
        Alt
        *THEN abc
        b
        Ket
        End
------------------------------------------------------------------

/(?:(*THEN:abc))a|(?:(*THEN:abc))b/B
------------------------------------------------------------------
        Bra
        Bra
        *THEN abc
        Ket
        a
        Alt
        Bra
        *THEN abc
        Ket
        b
        Ket
        End
------------------------------------------------------------------

# Common prefix which itself has a common prefix
# â‡’ (?>a[bc])[de]
/(?:(?>ab|ac)d|(?>ab|ac)e)/B
------------------------------------------------------------------
        Bra
        Once
        a
        [bc]
        Ket
        [de]
        Ket
        End
------------------------------------------------------------------

# Rewriting common prefix causes parent group to have a common prefix
# (We don't detect this case)
# â‡’ (?:a[bc]d|a[bc]e)
/(?:a(?:b|c)d|(?:ab|ac)e)/B
------------------------------------------------------------------
        Bra
        a
        [bc]
        d
        Alt
        a
        [bc]
        e
        Ket
        End
------------------------------------------------------------------

# Another case:
# â‡’ (?>a[bc]d|a[bc]e)
/(?>(?:ab|ac)d|(?:ab|ac)e)/B
------------------------------------------------------------------
        Bra
        Once
        a
        [bc]
        d
        Alt
        a
        [bc]
        e
        Ket
        Ket
        End
------------------------------------------------------------------

# When rewriting groups which are themselves quantified,
# the extracted items have to stay inside the quantified group
# â‡’ (?:a[bc])?
/(?:ab|ac)?/B
------------------------------------------------------------------
        Bra
        Brazero
        Bra
        a
        [bc]
        Ket
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac)*/B
------------------------------------------------------------------
        Bra
        Brazero
        Bra
        a
        [bc]
        KetRmax
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac)+/B
------------------------------------------------------------------
        Bra
        Bra
        a
        [bc]
        KetRmax
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac)?+/B
------------------------------------------------------------------
        Bra
        Once
        Brazero
        Bra
        a
        [bc]
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac)*+/B
------------------------------------------------------------------
        Bra
        Braposzero
        BraPos
        a
        [bc]
        KetRpos
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac)++/B
------------------------------------------------------------------
        Bra
        BraPos
        a
        [bc]
        KetRpos
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac){2}/B
------------------------------------------------------------------
        Bra
        Bra
        a
        [bc]
        Ket
        Bra
        a
        [bc]
        Ket
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac){2,4}/B
------------------------------------------------------------------
        Bra
        Bra
        a
        [bc]
        Ket
        Bra
        a
        [bc]
        Ket
        Brazero
        Bra
        Bra
        a
        [bc]
        Ket
        Brazero
        Bra
        a
        [bc]
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

/(?:ab|ac){2,4}+/B
------------------------------------------------------------------
        Bra
        Once
        Bra
        a
        [bc]
        Ket
        Bra
        a
        [bc]
        Ket
        Brazero
        Bra
        Bra
        a
        [bc]
        Ket
        Brazero
        Bra
        a
        [bc]
        Ket
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

# Regression test:
# Pattern rewriter must properly handle assert conditions which contain alternation
# This should not be rewritten:
/b(?(?!)|b)/B
------------------------------------------------------------------
        Bra
        b
        Cond
        *FAIL
        Alt
        b
        Ket
        Ket
        End
------------------------------------------------------------------

# Regression test:
# For a conditional group which uses an assertion condition, that assertion condition
# cannot be pulled out
# This should not be rewritten (and the subject string should not match):
/(?(?<!a)b|(?<!a))a/B
------------------------------------------------------------------
        Bra
        Cond
        Assert back not
        Reverse
        a
        Ket
        b
        Alt
        Assert back not
        Reverse
        a
        Ket
        Ket
        a
        Ket
        End
------------------------------------------------------------------
    a
No match

# Regression test:
# This conditional group must not be rewritten as (?(?=a)[bc]), because the two
# alternation branches of a conditional group are the "yes branch" and "no branch";
# They can't be combined
/(?(?=a)b|c)/B
------------------------------------------------------------------
        Bra
        Cond
        Assert
        a
        Ket
        b
        Alt
        c
        Ket
        Ket
        End
------------------------------------------------------------------

# Regression test:
# In the original implementation of the pattern rewriter, this regex tickled a bug
# whereby not enough memory was allocated for the rewritten pattern
/(?:c|d)a[.}[[.[:[[[[:.bb]]]/

# Regression test:
# META_COND_NUMBER was wrongly treated as the beginning of a grouping construct
# Then the leading 0 byte (which was part of its data) was taken as a common prefix
# This should not be rewritten:
/(a)(?(1)|\0)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
      1 Capture ref
        Alt
        \x00
        Ket
        Ket
        End
------------------------------------------------------------------

# No rewrite occurs if pattern rewriting is disabled
/ab|ac|ad/B,pattern_rewrite_off
------------------------------------------------------------------
        Bra
        ab
        Alt
        ac
        Alt
        ad
        Ket
        End
------------------------------------------------------------------

/ab|ac|ad/B,optimization_none
------------------------------------------------------------------
        Bra
        ab
        Alt
        ac
        Alt
        ad
        Ket
        End
------------------------------------------------------------------

/(*NO_REWRITE)ab|ac|ad/B
------------------------------------------------------------------
        Bra
        ab
        Alt
        ac
        Alt
        ad
        Ket
        End
------------------------------------------------------------------

# Rewrite into character class
# â‡’ [a-e]
/a|b|c|d|e/B
------------------------------------------------------------------
        Bra
        [a-e]
        Ket
        End
------------------------------------------------------------------

# Rewrite into common prefix followed by character class
/Xa|Xb|Xc/B
------------------------------------------------------------------
        Bra
        X
        [a-c]
        Ket
        End
------------------------------------------------------------------

# End of testinput28
